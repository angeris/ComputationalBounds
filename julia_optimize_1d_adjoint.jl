using SparseArrays
using PyPlot
using LinearAlgebra

function generate_lapl(n)
    L = SymTridiagonal(spdiagm(-1 => ones(n-1), 0 => -2*ones(n), 1 => ones(n-1)))
    return L
end

function linspace(s, e, n)
    return collect(range(s, e, length=n))
end

# all_dual = [0.004460418113102781, 10.398294500315258, 11.54098983412074, 2.2231065982567606, 4.189604392432056, 7.793132723939728, 3.8359103123119613, 3.841605057218319, 4.653637172604358, 3.650614668859536, 3.2620518966804486, 2.772683040514038, 2.365701395723395, 2.415759417588526, 2.0879059353063703, 1.8283372489881167, 1.834279596598419, 1.6728545268687753, 1.489007529005451, 1.4423737173679756, 1.3443350154330904, 1.2392997965309078, 1.1749687595438374, 1.1143998125541916, 1.0306867311645629, 0.9800522097995206, 0.9275265130381483, 0.8844241206155949, 0.8430432135208559, 0.7937016614870487, 0.7552323645845505, 0.7303805889224577, 0.7086653791918387, 0.6763418207955709, 0.6435286524782597, 0.6179875901245815, 0.5991310644967989, 0.5858377679580791, 0.5684739222649604, 0.5428197143690721, 0.5245888765784095, 0.525919003794538, 0.5127262637238807, 0.49651447078483635, 0.503196117722986, 0.4919597323976532, 0.4698838666043166, 0.4744298469573458, 0.47544177442320823, 0.4437906778648699, 0.45503575338466185, 0.46169868890306454, 0.464210089821389, 0.4533491082301513, 0.4639268950015971, 0.5070782562748217, 0.44653797093036296, 0.47586925057531637, 0.4559096098777342, 0.4647471582495193, 0.47152304531825173, 0.48001895860105037, 0.4874445230036475, 0.5056146741300438, 0.5383872583601708, 0.4853774159701505, 0.4880009691097502, 0.6035937933331468, 0.5973435672888456, 0.5527953366417115, 0.5960409538008946, 0.6019494772964329, 0.6302885066924588, 0.6513835930430041, 0.6513702682729487, 0.6757587480520986, 0.7038939771354187, 0.7313757766569182, 0.7518834261024168, 0.7947081185293889, 0.8851950588097335, 0.822216118061533, 0.9766315525472731, 0.9041751829458251, 0.9816125561896953, 1.0035446118257596, 1.02694187365804, 1.0642054184608112, 1.1066374310892009, 1.1465034878829155, 1.1960017431832792, 1.228472978600931, 1.2678095115724277, 1.315545414112461, 1.3417439141325858, 1.400113420606134, 1.4446287466718317, 1.4854213550705104, 1.519867099093526, 1.5772346365262777]

# all_dual = [0.004460418113102781, 8.267095325751729, 2.1593518256016795, 7.793955241658685, 4.029879160970415, 4.742919635601473, 3.2610744984801947, 2.452047117225443, 2.266769985916407, 1.8283377824133318, 1.7248444713955084, 1.4629411491111508, 1.344275127978384, 1.1910521462008514, 1.0927773696683047, 0.9801094679262068, 0.896833668924848, 0.8200180538965611, 0.7551758090524476, 0.7110666807042101, 0.6727539295254381, 0.617875490655404, 0.6000937204910954, 0.5541667500393714, 0.5248829010611953, 0.5135047410141063, 0.49690657769402335, 0.4921509257838004, 0.46252504347148715, 0.4750363621226761, 0.4553315819948409, 0.4497272277761777, 0.4473886257640345, 0.5065635386451515, 0.4314031726226055, 0.4716400373341578, 0.4716210910783314, 0.5057301758726975, 0.4957907021396064, 0.4864937846102535, 0.48583244484991894, 0.5414611471034476, 0.5957967715979589, 0.613856177192396, 0.6379895530705788, 0.6762211585147462, 0.7173593371764522, 0.7759321556760455, 0.8856061538786815, 0.7608419374779398, 1.025949707141904, 1.0032373876041936, 1.0494944182091368, 1.1093487135291422, 1.1959698412508875, 1.25470101197772, 1.3013383072363212, 1.400350083406945, 1.475698302459553, 1.5468534666660876, 1.617769797933903, 1.6901185362023297, 1.7586997539577371, 1.831658258732956, 1.9110304195223806, 1.9994607259607475, 2.0994426157005446, 2.1297212358074313, 2.1919490993621302, 2.263423034554873, 2.330442054096056, 2.3985810093587965, 2.4659630866437485, 2.5338702895870835, 2.6036342114482665, 2.665471801841379, 2.730260441418263, 2.7947538633055293, 2.8584410548216894, 2.92063021689083, 2.9836052349623117, 3.046391270951487, 3.1069157599340667, 3.1681946390936844, 3.22824890356514, 3.287834691570577, 3.3469787361298433, 3.4053582449718807, 3.463264437007857, 3.520648277268167, 3.5775001461272318, 3.633836003854915, 3.6893257989498007, 3.7443876395360087, 3.7989411941762885, 3.8529518810993606, 3.9065663379800277, 3.959189778318038, 4.011363738764769, 4.073166060713804]

all_dual = [0.006690627209933597, 7.03860140050572, 4.174151385060535, 2.496764339078732, 1.6859707132358466, 1.2239105266360575, 0.9518308228347827, 0.7756292478730149, 0.6682363478296232, 0.5914353433276229, 0.540021776159886, 0.5274583285014636, 0.5311501099827254, 0.552211374862944, 0.5993750082069678, 0.6556125976739011, 0.7339063442641294, 0.8143864234847342, 0.9887491561747268, 1.158370709992825, 1.3608001800493241, 1.5668593311900558, 1.8071799001104978, 2.0199797327879434, 2.245151476374291, 2.472178953252927, 2.6940585198676814, 2.9138398600967754, 3.133584340418645, 3.3786988911369047]

n = 30

all_primal = zeros(n)
all_w = linspace(.01*pi, 100*pi, n)

for idx = 1:n
    w = all_w[idx]
    N = 301
    # w = 30*pi
    t_min = 1
    t_max = 2 - t_min

    L = SymTridiagonal((N*N)/(w*w) * generate_lapl(N) + t_min * spdiagm(0 => ones(N)))

    x = linspace(0, 1, N)
    sigma = .1
    g = sin.(x*w).*exp.(-(x .- .5).^2 ./ (2*(sigma)^2))
    # g = sin.(x*w)
    # g[div(N-1,2):end] .= 0
    b = zeros(N)

    a_diag = ones(N)
    # a_diag[75:125] .= 1
    K = spdiagm(0 => a_diag)

    maxiter = 1000
    x_init = sin.(w*x)
    theta_init = t_min * ones(N)
    nu_init = zeros(N)
    l_init = zeros(N)

    # Begin adjoint optimization
    curr_x = copy(z_init)
    curr_theta_tilde = copy(theta_init)
    curr_theta = copy(theta_init)
    curr_nu = copy(nu_init)
    curr_l = copy(l_init)
    rho = 1.

    last_iter = 0

    prev_phys_res = +Inf
    prev_box_res = +Inf

    l_min_max = 1e10

    alpha = .99
    beta = 1.01

    for i=1:maxiter
        # Minimize field
        A = L + spdiagm(0 => curr_theta_tilde)
        S = Symmetric(K^2 + rho * A' * A)
        curr_x .= S \ (K' * g + rho * A' * (b - curr_nu))

        # Minimize theta_tilde
        diag_main = rho * curr_x .^ 2 .+ rho
        curr_theta_tilde .= (1 ./ diag_main).*(rho * curr_x .* (b - L * curr_x - curr_nu) +
                            rho*(curr_theta - curr_l))

        # Minimize theta
        curr_theta .= proj(curr_theta_tilde + curr_l, 0, t_max)

        # update all steps
        curr_l .+= curr_theta_tilde - curr_theta
        curr_nu .+= (L + spdiagm(0 => curr_theta_tilde)) * curr_x - b

        phys_resid = norm(L*curr_x + curr_theta_tilde .* curr_x - b)
        box_resid = norm(curr_theta - curr_theta_tilde)

        last_iter = i

        if ((phys_resid > 1e-4) || (box_resid > 1e-4))
            if (phys_resid >= alpha*prev_phys_res) || (box_resid >= alpha*prev_box_res)
                rho *= beta
            end
            prev_phys_res = phys_resid
            prev_box_res = box_resid

            continue
        end
    end

    all_primal[idx] = .5*norm(K*(curr_x - g))^2
end

title("Dual value vs. primal value")
plot(all_w, all_dual, label="Dual value", color="blue")
plot(all_w, all_primal, label="Primal value", linestyle=":", color="red")
legend()
xlabel("Frequency/Length")
ylabel(L"$\|f - \hat f\|_2^2$")
savefig("complete_output_plot_large.pdf")
close()
